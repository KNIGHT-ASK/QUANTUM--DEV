/**
 * PennyLane Code Generator
 * 
 * Translates QuantumIR → PennyLane Python code
 * Quantum ML ready with automatic differentiation
 */

import { QuantumIR, QuantumGate } from './QuantumIR';

export class PennyLaneGenerator {
	/**
	 * Generate complete PennyLane code from QuantumIR
	 */
	generateCode(ir: QuantumIR, options: {
		includeTesting?: boolean;
		includeOptimization?: boolean;
		device?: 'default.qubit' | 'qiskit.aer' | 'cirq.simulator';
	} = {}): string {
		const code: string[] = [];

		// Imports
		code.push(this.generateImports(ir, options));
		code.push('');

		// Documentation
		code.push(this.generateDocumentation(ir));
		code.push('');

		// Device setup
		code.push('# Configure quantum device');
		code.push(`dev = qml.device('${options.device || 'default.qubit'}', wires=${ir.hilbertSpace.numQubits})`);
		code.push('');

		// Circuit as QNode
		code.push('@qml.qnode(dev)');
		code.push('def quantum_circuit(params):');
		code.push('    """');
		code.push(`    ${ir.physicsMetadata.algorithm.name} quantum circuit`);
		code.push('    """');
		code.push('');

		// Initial state
		code.push(this.generateInitialState(ir));
		code.push('');

		// Gates with parameterization
		code.push('    # Apply quantum gates');
		let paramIdx = 0;
		for (const gate of ir.gates) {
			const pennylaneGate = this.generateGate(gate, paramIdx);
			if (pennylaneGate) {
				code.push(`    ${pennylaneGate}`);
				if (gate.type.startsWith('R')) paramIdx++;
			}
		}
		code.push('');

		// Return expectation value or measurements
		if (ir.physicsMetadata.algorithm.type === 'VQE') {
			code.push('    # Return energy expectation value');
			code.push('    # Replace with actual Hamiltonian observables');
			code.push('    return qml.expval(qml.PauliZ(0))');
		} else {
			code.push('    # Return measurement probabilities');
			code.push('    return qml.probs(wires=range(dev.num_wires))');
		}
		code.push('');

		// Optimization loop for VQE
		if (options.includeOptimization && ir.physicsMetadata.algorithm.type === 'VQE') {
			code.push(this.generateOptimization(ir));
			code.push('');
		}

		// Testing
		if (options.includeTesting) {
			code.push(this.generateTests(ir));
			code.push('');
		}

		// Main block
		code.push('if __name__ == "__main__":');
		code.push('    # Initialize parameters');
		code.push(`    num_params = ${this.countParameters(ir.gates)}`);
		code.push('    params = np.random.randn(num_params)');
		code.push('    ');
		code.push('    print("Quantum Circuit Info:")');
		code.push(`    print(f"  Device: {dev.name}")`);
		code.push(`    print(f"  Wires: {dev.num_wires}")`);
		code.push(` print(f"  Parameters: {num_params}")`);
		code.push('    ');

		if (options.includeOptimization) {
			code.push('    # Run optimization');
			code.push('    optimal_params, final_energy = run_vqe_optimization(params)');
			code.push('    print(f"\\nOptimal Energy: {final_energy:.6f}")');
		} else {
			code.push('    # Execute circuit');
			code.push('    result = quantum_circuit(params)');
			code.push('    print(f"\\nResult: {result}")');
		}

		code.push('    ');
		code.push('    # Visualize circuit');
		code.push('    print("\\nCircuit:")');
		code.push('    print(qml.draw(quantum_circuit)(params))');

		return code.join('\n');
	}

	private generateImports(ir: QuantumIR, options: any): string {
		const imports: string[] = [
			'"""',
			`${ir.physicsMetadata.algorithm.name} - Generated by Quantum Dev`,
			'PennyLane (Quantum ML) implementation',
			'"""',
			'',
			'import pennylane as qml',
			'import numpy as np'
		];

		if (options.includeOptimization) {
			imports.push('from pennylane import GradientDescentOptimizer, AdamOptimizer');
		}

		return imports.join('\n');
	}

	private generateDocumentation(ir: QuantumIR): string {
		const docs: string[] = [
			'"""',
			`QUANTUM ALGORITHM: ${ir.physicsMetadata.algorithm.name}`,
			'',
			`Type: ${ir.physicsMetadata.algorithm.type}`,
			`Qubits: ${ir.hilbertSpace.numQubits}`,
			''
		];

		if (ir.hamiltonian) {
			docs.push('HAMILTONIAN:');
			docs.push(`  ${ir.hamiltonian.description}`);
			if (ir.hamiltonian.groundStateEnergy) {
				docs.push(`  Target Energy: ${ir.hamiltonian.groundStateEnergy}`);
			}
			docs.push('');
		}

		docs.push('Generated by Quantum Dev - Physics-First Intelligence');
		docs.push('Framework: PennyLane (with automatic differentiation)');
		docs.push('"""');

		return docs.join('\n');
	}

	private generateInitialState(ir: QuantumIR): string {
		const lines: string[] = ['    # Initial state'];
		
		switch (ir.initialState.type) {
			case 'zero':
				lines.push('    # |0...0⟩ (default)');
				break;
			case 'plus':
				lines.push('    # |+...+⟩ (superposition)');
				for (let i = 0; i < ir.hilbertSpace.numQubits; i++) {
					lines.push(`    qml.Hadamard(wires=${i})`);
				}
				break;
			case 'custom':
				lines.push('    # Custom state preparation');
				lines.push('    if hasattr(dev, "target_state"):');
				lines.push('        import numpy as np');
				lines.push('        target = np.array(dev.target_state)');
				lines.push('        target = target / np.linalg.norm(target)  # Normalize');
				lines.push('        ');
				lines.push('        # Use QubitStateVector for state preparation');
				lines.push('        qml.QubitStateVector(target, wires=range(dev.num_wires))');
				lines.push('        print(f"✅ Custom state loaded: ||ψ|| = {np.linalg.norm(target):.10f}")');
				lines.push('    else:');
				lines.push('        print("⚠️  No target_state, using |0...0⟩")');
				break;
		}

		return lines.join('\n');
	}

	private generateGate(gate: QuantumGate, paramIdx: number): string | null {
		const wires = gate.qubits.map(q => `${q}`).join(', ');
		
		switch (gate.type) {
			case 'H':
				return `qml.Hadamard(wires=${wires})`;
			case 'X':
				return `qml.PauliX(wires=${wires})`;
			case 'Y':
				return `qml.PauliY(wires=${wires})`;
			case 'Z':
				return `qml.PauliZ(wires=${wires})`;
			case 'RX':
				return `qml.RX(params[${paramIdx}], wires=${wires})`;
			case 'RY':
				return `qml.RY(params[${paramIdx}], wires=${wires})`;
			case 'RZ':
				return `qml.RZ(params[${paramIdx}], wires=${wires})`;
			case 'CNOT':
				return `qml.CNOT(wires=[${wires}])`;
			case 'CZ':
				return `qml.CZ(wires=[${wires}])`;
			case 'SWAP':
				return `qml.SWAP(wires=[${wires}])`;
			case 'T':
				return `qml.T(wires=${wires})`;
			case 'S':
				return `qml.S(wires=${wires})`;
			default:
				return `# Unknown gate: ${gate.type}`;
		}
	}

	private generateOptimization(ir: QuantumIR): string {
		return `def run_vqe_optimization(initial_params, max_iterations=100):
    """
    Run VQE optimization using gradient descent
    Leverages PennyLane's automatic differentiation
    """
    # Choose optimizer (Adam for better convergence)
    opt = AdamOptimizer(stepsize=0.1)
    
    params = initial_params
    energies = []
    
    print("\\nStarting VQE Optimization...")
    print("Iter\\tEnergy")
    print("-" * 30)
    
    for i in range(max_iterations):
        # Update parameters using gradient descent
        params, energy = opt.step_and_cost(quantum_circuit, params)
        energies.append(energy)
        
        if i % 10 == 0:
            print(f"{i}\\t{energy:.6f}")
        
        # Check convergence
        if i > 10 and abs(energies[-1] - energies[-2]) < 1e-6:
            print(f"\\nConverged at iteration {i}")
            break
    
    return params, energy`;
	}

	private generateTests(ir: QuantumIR): string {
		return `def test_circuit():
    """Validate circuit and gradients"""
    params = np.random.randn(${this.countParameters(ir.gates)})
    
    # Test 1: Circuit executes
    try:
        result = quantum_circuit(params)
        assert result is not None
    except Exception as e:
        print(f"✗ Circuit execution failed: {e}")
        return False
    
    # Test 2: Gradient computation (automatic differentiation)
    try:
        grad_fn = qml.grad(quantum_circuit)
        gradients = grad_fn(params)
        assert gradients is not None
        assert len(gradients) == len(params)
    except Exception as e:
        print(f"✗ Gradient computation failed: {e}")
        return False
    
    print("✓ All PennyLane tests passed")
    return True`;
	}

	private countParameters(gates: QuantumGate[]): number {
		return gates.filter(g => g.type.startsWith('R')).length;
	}
}
