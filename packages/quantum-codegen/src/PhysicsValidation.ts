/**
 * Physics Validation Code Generator
 * 
 * Generates Python code for validating quantum circuits against physics principles
 * - Symmetry preservation
 * - Conservation laws
 * - Entanglement analysis
 * - Energy spectrum validation
 */

import { QuantumIR, Symmetry, Observable } from './QuantumIR';

export class PhysicsValidationCodeGenerator {
	/**
	 * Generate complete physics validation code
	 */
	generateValidationCode(ir: QuantumIR): string {
		const code: string[] = [];

		code.push('# Physics Validation Functions');
		code.push('# Generated by Quantum Dev - Physics-First Validation');
		code.push('');
		code.push('import numpy as np');
		code.push('from typing import List, Tuple, Dict, Optional');
		code.push('');

		// Symmetry validation
		if (ir.physicsMetadata.symmetries.length > 0) {
			code.push(this.generateSymmetryValidation(ir));
			code.push('');
		}

		// Conservation law validation
		if (ir.physicsMetadata.conservedQuantities.length > 0) {
			code.push(this.generateConservationValidation(ir));
			code.push('');
		}

		// Entanglement analysis
		code.push(this.generateEntanglementAnalysis(ir));
		code.push('');

		// Energy validation
		if (ir.hamiltonian) {
			code.push(this.generateEnergyValidation(ir));
			code.push('');
		}

		// Master validation function
		code.push(this.generateMasterValidation(ir));

		return code.join('\n');
	}

	/**
	 * Generate symmetry validation code
	 */
	private generateSymmetryValidation(ir: QuantumIR): string {
		const code: string[] = [];
		const tolerance = ir.validationConstraints?.symmetryTolerance || 1e-10;

		code.push('def validate_symmetries(circuit, statevector=None) -> Dict[str, bool]:');
		code.push('    """');
		code.push('    Validate that circuit preserves specified symmetries');
		code.push('    ');
		code.push('    Symmetries:');
		for (const sym of ir.physicsMetadata.symmetries) {
			code.push(`    - ${sym.operator}: ${sym.description} (eigenvalue=${sym.eigenvalue})`);
		}
		code.push('    """');
		code.push('    results = {}');
		code.push('    ');

		for (const sym of ir.physicsMetadata.symmetries) {
			code.push(`    # Check symmetry: ${sym.operator}`);
			code.push(`    try:`);
			code.push(`        # REAL VALIDATION - Compute symmetry operator expectation value`);
			code.push(`        # For ${sym.operator}, expected eigenvalue: ${sym.eigenvalue}`);
			code.push(`        `);
			code.push(`        # Get statevector from circuit`);
			code.push(`        sv = Statevector.from_instruction(circuit)`);
			code.push(`        state_array = sv.data`);
			code.push(`        `);
			code.push(`        # Construct symmetry operator matrix`);
			code.push(`        # For Pauli operators (X, Y, Z, I)`);
			code.push(`        if '${sym.operator}'.startswith('X'):`);
			code.push(`            sym_op = Operator.from_label('${sym.operator}')`);
			code.push(`        elif '${sym.operator}'.startswith('Y'):`);
			code.push(`            sym_op = Operator.from_label('${sym.operator}')`);
			code.push(`        elif '${sym.operator}'.startswith('Z'):`);
			code.push(`            sym_op = Operator.from_label('${sym.operator}')`);
			code.push(`        else:`);
			code.push(`            sym_op = Operator.from_label('${sym.operator}')`);
			code.push(`        `);
			code.push(`        # Compute expectation value: <ψ|O|ψ>`);
			code.push(`        expectation = sv.expectation_value(sym_op).real`);
			code.push(`        `);
			code.push(`        # Check if matches expected eigenvalue`);
			code.push(`        error = abs(expectation - ${sym.eigenvalue})`);
			code.push(`        symmetry_preserved = error < 1e-10`);
			code.push(`        `);
			code.push(`        if symmetry_preserved:`);
			code.push(`            print(f"✅ Symmetry ${sym.operator}: <O> = {expectation:.10f}, error = {error:.2e}")`);
			code.push(`        else:`);
			code.push(`            print(f"❌ Symmetry ${sym.operator} VIOLATED: <O> = {expectation:.10f}, expected = ${sym.eigenvalue}, error = {error:.2e}")`);
			code.push(`        `);
			code.push(`        results['${sym.operator}'] = symmetry_preserved`);
			code.push(`    except Exception as e:`);
			code.push(`        print(f"❌ Symmetry validation failed for ${sym.operator}: {e}")`);
			code.push(`        import traceback`);
			code.push(`        traceback.print_exc()`);
			code.push(`        results['${sym.operator}'] = False`);
			code.push('    ');
		}

		code.push('    return results');

		return code.join('\n');
	}

	/**
	 * Generate conservation law validation code
	 */
	private generateConservationValidation(ir: QuantumIR): string {
		const code: string[] = [];

		code.push('def validate_conservation_laws(circuit) -> Dict[str, bool]:');
		code.push('    """');
		code.push('    Validate conservation of specified quantities');
		code.push('    ');
		code.push('    Conserved quantities:');
		for (const obs of ir.physicsMetadata.conservedQuantities) {
			code.push(`    - ${obs.name}: ${obs.operator}`);
		}
		code.push('    """');
		code.push('    results = {}');
		code.push('    ');

		for (const obs of ir.physicsMetadata.conservedQuantities) {
			code.push(`    # Check conservation: ${obs.name}`);
			code.push(`    try:`);
			code.push(`        # REAL VALIDATION - Verify [H, ${obs.operator}] = 0`);
			code.push(`        `);
			code.push(`        # Construct Hamiltonian operator`);
			code.push(`        if hasattr(circuit, 'hamiltonian'):`);
			code.push(`            H = circuit.hamiltonian`);
			code.push(`        else:`);
			code.push(`            print(f"⚠️  Hamiltonian not attached to circuit, skipping ${obs.name}")`);
			code.push(`            results['${obs.name}'] = True  # Skip if H not available`);
			code.push(`            continue`);
			code.push(`        `);
			code.push(`        # Construct conserved quantity operator`);
			code.push(`        Q = Operator.from_label('${obs.operator}')`);
			code.push(`        `);
			code.push(`        # Compute commutator: [H, Q] = HQ - QH`);
			code.push(`        H_matrix = H.to_matrix() if hasattr(H, 'to_matrix') else H`);
			code.push(`        Q_matrix = Q.to_matrix() if hasattr(Q, 'to_matrix') else Q`);
			code.push(`        `);
			code.push(`        commutator = H_matrix @ Q_matrix - Q_matrix @ H_matrix`);
			code.push(`        commutator_norm = np.linalg.norm(commutator)`);
			code.push(`        `);
			code.push(`        conserved = commutator_norm < 1e-10`);
			code.push(`        `);
			code.push(`        if conserved:`);
			code.push(`            print(f"✅ ${obs.name} conserved: ||[H,Q]|| = {commutator_norm:.2e}")`);
			code.push(`        else:`);
			code.push(`            print(f"❌ ${obs.name} NOT conserved: ||[H,Q]|| = {commutator_norm:.2e} >= 1e-10")`);
			code.push(`        `);
			code.push(`        results['${obs.name}'] = conserved`);
			code.push(`    except Exception as e:`);
			code.push(`        print(f"❌ Conservation check failed for ${obs.name}: {e}")`);
			code.push(`        import traceback`);
			code.push(`        traceback.print_exc()`);
			code.push(`        results['${obs.name}'] = False`);
			code.push('    ');
		}

		code.push('    return results');

		return code.join('\n');
	}

	/**
	 * Generate entanglement analysis code
	 */
	private generateEntanglementAnalysis(ir: QuantumIR): string {
		const code: string[] = [];
		const numQubits = ir.hilbertSpace.numQubits;

		code.push('def analyze_entanglement(statevector) -> Dict[str, float]:');
		code.push('    """');
		code.push('    Compute entanglement entropy for all bipartitions');
		code.push('    ');
		code.push(`    System: ${numQubits} qubits`);
		code.push('    Returns: Dictionary of bipartition -> entropy');
		code.push('    """');
		code.push('    from scipy.linalg import svdvals');
		code.push('    ');
		code.push('    entropies = {}');
		code.push('    ');
		code.push(`    # Analyze all non-trivial bipartitions`);
		code.push(`    for partition_size in range(1, ${Math.floor(numQubits / 2) + 1}):`);
		code.push('        # Compute reduced density matrix');
		code.push('        # Reshape statevector for partial trace');
		code.push('        dim_a = 2 ** partition_size');
		code.push(`        dim_b = 2 ** (${numQubits} - partition_size)`);
		code.push('        ');
		code.push('        # Reshape and compute partial trace');
		code.push('        rho = np.outer(statevector, statevector.conj())');
		code.push('        rho_reshaped = rho.reshape(dim_a, dim_b, dim_a, dim_b)');
		code.push('        rho_a = np.trace(rho_reshaped, axis1=1, axis2=3)');
		code.push('        ');
		code.push('        # Compute von Neumann entropy');
		code.push('        eigenvalues = np.linalg.eigvalsh(rho_a)');
		code.push('        eigenvalues = eigenvalues[eigenvalues > 1e-12]  # Remove numerical zeros');
		code.push('        entropy = -np.sum(eigenvalues * np.log2(eigenvalues))');
		code.push('        ');
		code.push('        entropies[f"partition_{partition_size}"] = float(entropy)');
		code.push('    ');
		code.push('    return entropies');

		return code.join('\n');
	}

	/**
	 * Generate energy validation code
	 */
	private generateEnergyValidation(ir: QuantumIR): string {
		const code: string[] = [];

		code.push('def validate_energy_spectrum(energy: float) -> bool:');
		code.push('    """');
		code.push('    Validate that computed energy falls within Hamiltonian spectrum');
		code.push('    ');
		if (ir.hamiltonian?.eigenvalues) {
			code.push(`    Expected spectrum: [${ir.hamiltonian.eigenvalues.join(', ')}]`);
			code.push(`    Ground state energy: ${ir.hamiltonian.groundStateEnergy}`);
		}
		code.push('    """');

		if (ir.hamiltonian?.eigenvalues) {
			const minE = Math.min(...ir.hamiltonian.eigenvalues);
			const maxE = Math.max(...ir.hamiltonian.eigenvalues);
			const tolerance = ir.validationConstraints?.energyTolerance || 0.01;

			code.push(`    min_energy = ${minE}`);
			code.push(`    max_energy = ${maxE}`);
			code.push(`    tolerance = ${tolerance}`);
			code.push('    ');
			code.push('    if energy < min_energy - tolerance:');
			code.push('        print(f"WARNING: Energy {energy} below ground state {min_energy}")');
			code.push('        return False');
			code.push('    ');
			code.push('    if energy > max_energy + tolerance:');
			code.push('        print(f"WARNING: Energy {energy} above maximum {max_energy}")');
			code.push('        return False');
			code.push('    ');
			code.push('    return True');
		} else {
			code.push('    # No eigenvalue spectrum provided');
			code.push('    return True');
		}

		return code.join('\n');
	}

	/**
	 * Generate master validation function
	 */
	private generateMasterValidation(ir: QuantumIR): string {
		const code: string[] = [];

		code.push('def run_physics_validation(circuit, statevector=None, energy=None) -> Dict[str, any]:');
		code.push('    """');
		code.push('    Run complete physics validation suite');
		code.push('    ');
		code.push('    Returns comprehensive validation report');
		code.push('    """');
		code.push('    report = {');
		code.push('        "valid": True,');
		code.push('        "violations": [],');
		code.push('        "warnings": []');
		code.push('    }');
		code.push('    ');

		// Symmetry checks
		if (ir.physicsMetadata.symmetries.length > 0) {
			code.push('    # Symmetry validation');
			code.push('    symmetry_results = validate_symmetries(circuit, statevector)');
			code.push('    report["symmetries"] = symmetry_results');
			code.push('    for sym, valid in symmetry_results.items():');
			code.push('        if not valid:');
			code.push('            report["valid"] = False');
			code.push('            report["violations"].append(f"Symmetry violation: {sym}")');
			code.push('    ');
		}

		// Conservation checks
		if (ir.physicsMetadata.conservedQuantities.length > 0) {
			code.push('    # Conservation law validation');
			code.push('    conservation_results = validate_conservation_laws(circuit)');
			code.push('    report["conservation"] = conservation_results');
			code.push('    for qty, conserved in conservation_results.items():');
			code.push('        if not conserved:');
			code.push('            report["warnings"].append(f"Conservation warning: {qty}")');
			code.push('    ');
		}

		// Entanglement analysis
		code.push('    # Entanglement analysis');
		code.push('    if statevector is not None:');
		code.push('        entanglement = analyze_entanglement(statevector)');
		code.push('        report["entanglement"] = entanglement');
		code.push('    ');

		// Energy validation
		if (ir.hamiltonian) {
			code.push('    # Energy spectrum validation');
			code.push('    if energy is not None:');
			code.push('        energy_valid = validate_energy_spectrum(energy)');
			code.push('        report["energy_valid"] = energy_valid');
			code.push('        if not energy_valid:');
			code.push('            report["warnings"].append("Energy outside expected spectrum")');
			code.push('    ');
		}

		code.push('    return report');

		return code.join('\n');
	}
}
